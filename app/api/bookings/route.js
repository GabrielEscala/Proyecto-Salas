import { NextResponse } from "next/server";
import supabase from "@/lib/supabaseClient";
import { FITUR_ROOM_SEED } from "@/lib/constants";
import { composeBookingNotes, parseBookingNotes } from "@/lib/booking-notes";
import {
  generateTimeSlots,
  getNextAvailableSlot,
  isDateBeforeToday,
  isSlotInPast,
  getSlotEndTime,
  getTodayString
} from "@/lib/time";
import { generateCancelCode } from "@/lib/codes";
import { buildBookingEmailHtml, sendBookingEmail } from "@/lib/mailer";

export const runtime = "nodejs";

const slots = generateTimeSlots();

const MEMORY_BOOKINGS = globalThis.__SALAS_MEMORY_BOOKINGS__ ?? (globalThis.__SALAS_MEMORY_BOOKINGS__ = []);

const createId = () =>
  globalThis.crypto?.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const normalizeTime = (time) => (time?.length ? time.slice(0, 5) : time);

const FITUR_TIME_ZONE = "Europe/Madrid";
const DEFAULT_TIME_ZONE = "America/Caracas";
const FITUR_NAMES = new Set(FITUR_ROOM_SEED.map((r) => r.name));
const IS_VERCEL = !!process.env.VERCEL || !!process.env.VERCEL_URL;

const resolveSupabaseRoomId = async (roomId) => {
  const key = String(roomId || "");
  if (!supabase) return roomId;
  if (!key.startsWith("fitur:")) return roomId;

  const seed = FITUR_ROOM_SEED.find((r) => r.id === key);
  const name = seed?.name;
  if (!name) return roomId;

  try {
    const { data: existing, error: fetchError } = await supabase
      .from("rooms")
      .select("id, name")
      .eq("name", name)
      .limit(1);
    if (!fetchError && Array.isArray(existing) && existing[0]?.id) return existing[0].id;

    // attempt to create missing room (id is generated by DB)
    await supabase.from("rooms").insert({ name });

    const { data: created } = await supabase
      .from("rooms")
      .select("id, name")
      .eq("name", name)
      .limit(1);
    if (Array.isArray(created) && created[0]?.id) return created[0].id;
  } catch {
    // ignore
  }

  return roomId;
};

const resolveTimeZoneForRoomId = async (roomId) => {
  const key = String(roomId || "");
  if (key.startsWith("fitur:")) return FITUR_TIME_ZONE;

  if (!supabase || !roomId) return DEFAULT_TIME_ZONE;
  try {
    const { data, error } = await supabase
      .from("rooms")
      .select("name")
      .eq("id", roomId)
      .limit(1);
    if (error) return DEFAULT_TIME_ZONE;
    const name = Array.isArray(data) && data[0] ? data[0].name : null;
    if (name && FITUR_NAMES.has(name)) return FITUR_TIME_ZONE;
    return DEFAULT_TIME_ZONE;
  } catch {
    return DEFAULT_TIME_ZONE;
  }
};

const getBaseUrl = () => {
  let baseUrl = process.env.NEXT_PUBLIC_APP_URL;
  if (!baseUrl) {
    if (process.env.VERCEL_URL) {
      baseUrl = `https://${process.env.VERCEL_URL}`;
    } else {
      baseUrl = "http://localhost:3000";
    }
  }
  return baseUrl;
};

const buildCancelUrl = (cancelCode) => `${getBaseUrl()}/manage/${cancelCode}`;

const getMemoryBookings = ({ date, roomId, cancelCode }) => {
  const filtered = MEMORY_BOOKINGS.filter((b) => {
    if (cancelCode) return b.cancel_code === cancelCode;
    if (date && b.date !== date) return false;
    if (roomId && b.room_id !== roomId) return false;
    return true;
  });

  return filtered.map((row) => formatBookingRow({ ...row, _storage: "memory" }));
};

const createMemoryBookingResponse = async ({ roomId, firstName, lastName, email, company, clients, date, time, times, storageReason, storageError }) => {
  const requestedTimes = Array.isArray(times)
    ? times
    : time
      ? [time]
      : [];

  if (!roomId || !firstName || !lastName || !email || !company || !date || !requestedTimes.length) {
    return NextResponse.json(
      { error: "Todos los campos son obligatorios." },
      { status: 400 }
    );
  }

  const uniqueTimes = [...new Set(requestedTimes.map(normalizeTime))].filter(Boolean);

  const timeZone = String(roomId || "").startsWith("fitur:") ? FITUR_TIME_ZONE : DEFAULT_TIME_ZONE;

  if (isDateBeforeToday(date, new Date(), timeZone)) {
    return NextResponse.json(
      { error: "No puedes reservar en fechas pasadas." },
      { status: 422 }
    );
  }

  const todayString = getTodayString(new Date(), timeZone);
  if (date === todayString) {
    const pastSlot = uniqueTimes.find((slot) => isSlotInPast(date, slot, new Date(), timeZone));
    if (pastSlot) {
      return NextResponse.json(
        { error: `El horario ${pastSlot} ya pasó.` },
        { status: 422 }
      );
    }
  }

  const invalidSlot = uniqueTimes.find((slot) => !slots.includes(slot));
  if (invalidSlot) {
    return NextResponse.json(
      { error: `El horario ${invalidSlot} es inválido.` },
      { status: 422 }
    );
  }

  const dayBookings = MEMORY_BOOKINGS.filter((b) => b.date === date && b.room_id === roomId);
  const conflicts = uniqueTimes
    .map((slot) => dayBookings.find((b) => normalizeTime(b.time) === slot))
    .filter(Boolean);

  if (conflicts.length) {
    const suggestion = getNextAvailableSlot(
      slots,
      dayBookings.map((b) => ({ ...b, time: normalizeTime(b.time) })),
      date,
      normalizeTime(conflicts[0].time)
    );

    return NextResponse.json(
      {
        error: "La sala ya está reservada en ese horario.",
        conflicts: conflicts.map((booking) => ({
          first_name: booking.first_name,
          last_name: booking.last_name,
          time: normalizeTime(booking.time)
        })),
        suggestion
      },
      { status: 409 }
    );
  }

  const cancelCode = generateCancelCode();
  const composedNotes = composeBookingNotes({ company, clients });
  const insertPayload = uniqueTimes.map((slot) => ({
    id: createId(),
    room_id: roomId,
    first_name: firstName.trim(),
    last_name: lastName.trim(),
    email: email.trim().toLowerCase(),
    notes: composedNotes || null,
    company: String(company || "").trim() || null,
    date,
    time: `${slot}:00`,
    cancel_code: cancelCode
  }));

  MEMORY_BOOKINGS.push(...insertPayload);

  const formatted = insertPayload.map(formatBookingRow);
  const lastTime = formatted[formatted.length - 1].time;
  const timeRange = formatted.length > 1
    ? `${formatted[0].time} - ${getSlotEndTime(lastTime)}`
    : formatted[0].time;

  const cancelUrl = buildCancelUrl(cancelCode);

  let emailStatus = { ok: false, status: "skipped", reason: "not_attempted" };

  try {
    const html = buildBookingEmailHtml({
      firstName,
      lastName,
      company,
      roomName: formatted?.[0]?.room_name || "",
      date,
      timeRange,
      cancelCode,
      cancelUrl
    });
    emailStatus = await sendBookingEmail({
      to: email,
      subject: `Reserva confirmada - ${formatted?.[0]?.room_name || "Sala"}`,
      html
    });
  } catch (_) {
    emailStatus = { ok: false, status: "error", error: "unexpected" };
  }

  return NextResponse.json(
    {
      ...formatted[0],
      storage: "memory",
      storage_reason: storageReason || null,
      supabase_error: storageError || null,
      cancel_code: cancelCode,
      cancel_url: cancelUrl,
      time_range: timeRange,
      email_provider: emailStatus?.provider || null,
      email_status: emailStatus?.status,
      email_error: emailStatus?.status === "error" ? emailStatus?.error || null : null,
      email_skip_reason: emailStatus?.status === "skipped" ? emailStatus?.reason || null : null,
      email_message_id: emailStatus?.status === "sent" ? emailStatus?.messageId || null : null,
      all_bookings: formatted
    },
    { status: 201 }
  );
};

const formatBookingRow = (row) => ({
  ...(parseBookingNotes(row.notes ?? row.company) || {}),
  id: row.id,
  room_id: row.room_id,
  date: row.date,
  time: row.time?.slice(0, 5) ?? row.time,
  first_name: row.first_name,
  last_name: row.last_name,
  email: row.email ?? null,
  company: (parseBookingNotes(row.notes ?? row.company)?.company ?? row.company ?? row.notes) ?? null,
  clients: (parseBookingNotes(row.notes ?? row.company)?.clients ?? row.clients) ?? null,
  cancel_code: row.cancel_code,
  room_name: row.rooms?.name ?? row.room_name,
  storage: row.storage ?? row._storage ?? (row.rooms ? "supabase" : "memory")
});

const timeWithSeconds = (time) => (time?.length === 5 ? `${time}:00` : time);

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const date = searchParams.get("date");
  const roomId = searchParams.get("roomId");
  const cancelCode = searchParams.get("cancelCode");

  if (!supabase) {
    return NextResponse.json(getMemoryBookings({ date, roomId, cancelCode }), {
      headers: {
        "x-salas-storage": "memory",
        "x-salas-storage-reason": "supabase_not_configured"
      }
    });
  }

  try {
    // Si se busca por código de cancelación
    if (cancelCode) {
      const { data, error } = await supabase
        .from("bookings")
        .select("id, room_id, date, time, first_name, last_name, email, notes, cancel_code, rooms(name)")
        .eq("cancel_code", cancelCode)
        .order("time", { ascending: true });

      if (error) {
        return NextResponse.json(getMemoryBookings({ date, roomId, cancelCode }), {
          headers: {
            "x-salas-storage": "memory",
            "x-salas-storage-reason": "supabase_error",
            "x-salas-supabase-error": (error?.message || "").slice(0, 200)
          }
        });
      }

      const merged = [
        ...((data || []).map(formatBookingRow)),
        ...getMemoryBookings({ date, roomId, cancelCode })
      ];

      const byKey = new Map();
      for (const b of merged) {
        const key = `${b.room_id}|${b.date}|${b.time}|${b.cancel_code || ""}`;
        if (!byKey.has(key)) byKey.set(key, b);
      }

      const result = Array.from(byKey.values()).sort((a, b) => (a.time || "").localeCompare(b.time || ""));
      if (result.length === 0) {
        return NextResponse.json(
          { error: "Código no encontrado." },
          { status: 404 }
        );
      }

      return NextResponse.json(result, {
        headers: {
          "x-salas-storage": "supabase"
        }
      });
    }

    // Búsqueda normal por fecha
    if (!date) {
      return NextResponse.json(
        { error: "El parámetro date es obligatorio (o usa cancelCode)." },
        { status: 400 }
      );
    }

    let query = supabase
      .from("bookings")
      .select("id, room_id, date, time, first_name, last_name, email, notes, cancel_code, rooms(name)")
      .eq("date", date)
      .order("time", { ascending: true });

    const resolvedRoomId = await resolveSupabaseRoomId(roomId);
    if (resolvedRoomId) {
      query = query.eq("room_id", resolvedRoomId);
    }

    const { data, error } = await query;

    if (error) {
      if (IS_VERCEL) {
        return NextResponse.json(
          { error: "Servicio temporalmente no disponible. Intenta nuevamente." },
          {
            status: 503,
            headers: {
              "x-salas-storage": "supabase",
              "x-salas-supabase-error": (error?.message || "").slice(0, 200)
            }
          }
        );
      }

      return NextResponse.json(getMemoryBookings({ date, roomId, cancelCode }), {
        headers: {
          "x-salas-storage": "memory",
          "x-salas-storage-reason": "supabase_error",
          "x-salas-supabase-error": (error?.message || "").slice(0, 200)
        }
      });
    }

    const merged = [
      ...((data || []).map(formatBookingRow)),
      ...getMemoryBookings({ date, roomId, cancelCode })
    ];

    const byKey = new Map();
    for (const b of merged) {
      const key = `${b.room_id}|${b.date}|${b.time}`;
      if (!byKey.has(key)) byKey.set(key, b);
    }

    const result = Array.from(byKey.values()).sort((a, b) => (a.time || "").localeCompare(b.time || ""));
    return NextResponse.json(result, {
      headers: {
        "x-salas-storage": "supabase"
      }
    });
  } catch (error) {
    if (IS_VERCEL) {
      return NextResponse.json(
        { error: "Servicio temporalmente no disponible. Intenta nuevamente." },
        {
          status: 503,
          headers: {
            "x-salas-storage": "supabase",
            "x-salas-supabase-error": (error?.message || "").slice(0, 200)
          }
        }
      );
    }

    return NextResponse.json(getMemoryBookings({ date, roomId, cancelCode }), {
      headers: {
        "x-salas-storage": "memory",
        "x-salas-storage-reason": "supabase_error",
        "x-salas-supabase-error": (error?.message || "").slice(0, 200)
      }
    });
  }
}

export async function POST(request) {
  try {
    if (!supabase) {
      const body = await request.json();
      return await createMemoryBookingResponse({ ...body, storageReason: "supabase_not_configured" });
    }

  const body = await request.json();
  const { roomId, firstName, lastName, email, company, clients, date, time, times } = body;
  const resolvedRoomId = await resolveSupabaseRoomId(roomId);
  const requestedTimes = Array.isArray(times)
    ? times
    : time
      ? [time]
      : [];

  if (!resolvedRoomId || !firstName || !lastName || !email || !company || !date || !requestedTimes.length) {
    return NextResponse.json(
      { error: "Todos los campos son obligatorios." },
      { status: 400 }
    );
  }

  const uniqueTimes = [...new Set(requestedTimes)];

  const timeZone = await resolveTimeZoneForRoomId(resolvedRoomId);

  if (isDateBeforeToday(date, new Date(), timeZone)) {
    return NextResponse.json(
      { error: "No puedes reservar en fechas pasadas." },
      { status: 422 }
    );
  }

  const todayString = getTodayString(new Date(), timeZone);
  if (date === todayString) {
    const pastSlot = uniqueTimes.find((slot) => isSlotInPast(date, slot, new Date(), timeZone));
    if (pastSlot) {
      return NextResponse.json(
        { error: `El horario ${pastSlot} ya pasó.` },
        { status: 422 }
      );
    }
  }

  const invalidSlot = uniqueTimes.find((slot) => !slots.includes(slot));
  if (invalidSlot) {
    return NextResponse.json(
      { error: `El horario ${invalidSlot} es inválido.` },
      { status: 422 }
    );
  }

  const { data: dayBookings = [], error: dayError } = await supabase
    .from("bookings")
    .select("id, room_id, date, time, first_name, last_name")
    .eq("date", date)
    .eq("room_id", resolvedRoomId);

  if (dayError) {
    if (IS_VERCEL) {
      return NextResponse.json(
        { error: "No pudimos procesar la reserva. Intenta nuevamente." },
        { status: 503 }
      );
    }
    return await createMemoryBookingResponse({ roomId: resolvedRoomId, firstName, lastName, email, company, clients, date, time, times, storageReason: "supabase_error", storageError: dayError?.message });
  }

  // Verificar conflictos: debe ser la misma sala Y el mismo horario
  const conflicts = uniqueTimes
    .map((slot) => {
      const conflict = dayBookings.find(
        (booking) => 
          booking.room_id === resolvedRoomId && // Misma sala
          booking.time?.startsWith(slot) // Mismo horario
      );
      return conflict;
    })
    .filter(Boolean);

  if (conflicts.length) {
    const suggestion = getNextAvailableSlot(slots, dayBookings, date, conflicts[0].time?.slice(0, 5));
    return NextResponse.json(
      {
        error: "La sala ya está reservada en ese horario.",
        conflicts: conflicts.map((booking) => ({
          first_name: booking.first_name,
          last_name: booking.last_name,
          time: booking.time?.slice(0, 5)
        })),
        suggestion
      },
      { status: 409 }
    );
  }

  // Generar código único para todo el grupo de reservas
  const cancelCode = generateCancelCode();
  
  // Validar que todos los slots tengan el formato correcto
  const insertPayload = uniqueTimes
    .map((slot) => {
      const timeFormatted = timeWithSeconds(slot);
      if (!timeFormatted || timeFormatted.length !== 8) {
        return null;
      }
      return {
        room_id: resolvedRoomId,
        first_name: firstName.trim(),
        last_name: lastName.trim(),
        email: email.trim().toLowerCase(),
        notes: composeBookingNotes({ company, clients }) || null,
        date,
        time: timeFormatted,
        cancel_code: cancelCode
      };
    })
    .filter(Boolean);

  if (insertPayload.length === 0) {
    return NextResponse.json(
      { error: "No hay horarios válidos para reservar." },
      { status: 400 }
    );
  }

          const { data, error } = await supabase
    .from("bookings")
    .insert(insertPayload)
    .select("id, room_id, date, time, first_name, last_name, email, notes, cancel_code, rooms(name)");

  if (error) {
    if (IS_VERCEL) {
      return NextResponse.json(
        { error: "No pudimos guardar la reserva. Intenta nuevamente." },
        { status: 503 }
      );
    }
    return await createMemoryBookingResponse({ roomId: resolvedRoomId, firstName, lastName, email, company, clients, date, time, times, storageReason: "supabase_error", storageError: error?.message });
  }

          const formatted = (Array.isArray(data) ? data : [data]).map(formatBookingRow);
          
          if (!formatted || formatted.length === 0) {
            if (IS_VERCEL) {
              return NextResponse.json(
                { error: "No pudimos guardar la reserva. Intenta nuevamente." },
                { status: 503 }
              );
            }
            return await createMemoryBookingResponse({ roomId: resolvedRoomId, firstName, lastName, email, company, clients, date, time, times, storageReason: "supabase_error", storageError: "Empty insert result" });
          }
  
  const firstBooking = formatted[0];
  const lastTime = formatted[formatted.length - 1].time;
  const timeRange = formatted.length > 1
    ? `${formatted[0].time} - ${getSlotEndTime(lastTime)}`
    : formatted[0].time;

  const cancelUrl = buildCancelUrl(cancelCode);

  let emailStatus = { ok: false, status: "skipped", reason: "not_attempted" };

  try {
    const html = buildBookingEmailHtml({
      firstName,
      lastName,
      company,
      roomName: firstBooking.room_name || "",
      date,
      timeRange,
      cancelCode,
      cancelUrl
    });
    emailStatus = await sendBookingEmail({
      to: email,
      subject: `Reserva confirmada - ${firstBooking.room_name || "Sala"}`,
      html
    });
  } catch (_) {
    emailStatus = { ok: false, status: "error", error: "unexpected" };
  }

  return NextResponse.json(
    {
      ...formatted[0],
      storage: "supabase",
      cancel_code: cancelCode,
      cancel_url: cancelUrl,
      time_range: timeRange,
      email_provider: emailStatus?.provider || null,
      email_status: emailStatus?.status,
      email_error: emailStatus?.status === "error" ? emailStatus?.error || null : null,
      email_skip_reason: emailStatus?.status === "skipped" ? emailStatus?.reason || null : null,
      email_message_id: emailStatus?.status === "sent" ? emailStatus?.messageId || null : null,
      all_bookings: formatted
    },
    { status: 201 }
  );
  } catch (error) {
    try {
      const body = await request.json();
      return await createMemoryBookingResponse({ ...body, storageReason: "supabase_error", storageError: error?.message });
    } catch {
      return NextResponse.json(
        { error: "Ocurrió un error inesperado al crear la reserva." },
        { status: 500 }
      );
    }
  }
}

